"""
Agent Manager Service
Component 8: Pydantic AI Agents

Manages lifecycle and initialization of all Pydantic AI agents.
Provides centralized access to agents with proper dependency injection.
"""

import logging
from typing import Optional

from httpx import AsyncClient

from agents.web_crawl_coordinator import (
    web_crawl_coordinator,
    WebCrawlDeps,
    coordinate_web_crawl
)
from agents.doc_process_coordinator import (
    doc_process_coordinator,
    DocProcessDeps,
    coordinate_doc_processing
)
from agents.query_router import (
    query_router_agent,
    QueryRouterDeps,
    route_query
)
from config.settings import settings

logger = logging.getLogger("shield-orchestrator.agent_manager")


class AgentManager:
    """
    Centralized manager for all Pydantic AI agents.
    
    Provides:
    - Agent lifecycle management
    - Dependency injection
    - Shared resources (HTTP clients, etc.)
    - Health monitoring
    """
    
    def __init__(self):
        """Initialize agent manager"""
        self._http_client: Optional[AsyncClient] = None
        self._initialized = False
        self._last_llm_check: Optional[float] = None
        self._llm_check_result: Optional[str] = None
        self._llm_check_ttl: float = 60.0  # Cache for 60 seconds
        logger.info("Agent manager created")
    
    async def initialize(self):
        """
        Initialize agent manager and all agents.
        
        Called during application startup.
        """
        if self._initialized:
            logger.warning("Agent manager already initialized")
            return
        
        try:
            # Initialize shared HTTP client
            self._http_client = AsyncClient(
                timeout=30.0,
                follow_redirects=True,
                limits=AsyncClient.Limits(
                    max_connections=100,
                    max_keepalive_connections=20
                )
            )
            
            # Verify LiteLLM connectivity
            await self._verify_llm_connection()
            
            self._initialized = True
            logger.info("Agent manager initialized successfully")
            
        except Exception as e:
            logger.error(f"Failed to initialize agent manager: {e}")
            raise
    
    async def shutdown(self):
        """
        Shutdown agent manager and cleanup resources.
        
        Called during application shutdown.
        """
        if not self._initialized:
            return
        
        try:
            if self._http_client:
                await self._http_client.aclose()
                self._http_client = None
            
            self._initialized = False
            logger.info("Agent manager shut down successfully")
            
        except Exception as e:
            logger.error(f"Error during agent manager shutdown: {e}")
    
    async def _verify_llm_connection(self):
        """Verify LiteLLM proxy is accessible"""
        try:
            from openai import AsyncOpenAI
            
            client = AsyncOpenAI(
                base_url=settings.llm_api_base,
                api_key=settings.llm_api_key.get_secret_value()
            )
            
            # Simple health check
            models = await client.models.list()
            logger.info(f"LiteLLM connection verified: {len(models.data)} models available")
            
        except Exception as e:
            logger.error(f"LiteLLM connection failed: {e}")
            raise
    
    # Agent access methods
    
    def get_web_crawl_deps(self, brave_api_key: Optional[str] = None) -> WebCrawlDeps:
        """
        Get dependencies for web crawl coordinator.
        
        Args:
            brave_api_key: Optional Brave Search API key
        
        Returns:
            WebCrawlDeps instance
        """
        if not self._http_client:
            raise RuntimeError("Agent manager not initialized")
        
        return WebCrawlDeps(
            client=self._http_client,
            brave_api_key=brave_api_key
        )
    
    def get_doc_process_deps(self) -> DocProcessDeps:
        """
        Get dependencies for document process coordinator.
        
        Returns:
            DocProcessDeps instance
        """
        return DocProcessDeps()
    
    def get_query_router_deps(self) -> QueryRouterDeps:
        """
        Get dependencies for query router.
        
        Returns:
            QueryRouterDeps instance
        """
        return QueryRouterDeps()
    
    # Convenience methods for agent execution
    
    async def coordinate_web_crawl(
        self,
        url: str,
        allowed_domains: list[str],
        max_pages: int = {{ web_crawl_max_pages | default(10) }},
        brave_api_key: Optional[str] = None
    ) -> dict:
        """
        Execute web crawl coordination.
        
        Args:
            url: Starting URL
            allowed_domains: List of allowed domains
            max_pages: Maximum pages to crawl
            brave_api_key: Optional Brave Search API key
        
        Returns:
            Crawl plan dictionary
        """
        if not self._initialized:
            raise RuntimeError("Agent manager not initialized")
        
        logger.info(f"Coordinating web crawl from {url}")
        
        # Get deps with brave_api_key if provided
        deps = self.get_web_crawl_deps(brave_api_key=brave_api_key)
        
        return await coordinate_web_crawl(
            url=url,
            allowed_domains=allowed_domains,
            max_pages=max_pages,
            deps=deps
        )
    
    async def coordinate_document_processing(
        self,
        content_preview: str,
        file_type: str,
        document_size: int
    ) -> dict:
        """
        Execute document processing coordination.
        
        Args:
            content_preview: Preview of document content
            file_type: File extension
            document_size: Document size in bytes
        
        Returns:
            Document analysis dictionary
        """
        if not self._initialized:
            raise RuntimeError("Agent manager not initialized")
        
        logger.info(f"Coordinating document processing for {file_type}")
        
        result = await coordinate_doc_processing(
            content_preview=content_preview,
            file_type=file_type,
            document_size=document_size
        )
        
        return result.model_dump()
    
    async def route_query(self, query: str) -> dict:
        """
        Execute query routing.
        
        Args:
            query: User's query string
        
        Returns:
            Routing decision dictionary
        """
        if not self._initialized:
            raise RuntimeError("Agent manager not initialized")
        
        logger.info(f"Routing query: {query[:100]}")
        
        result = await route_query(query)
        return result.model_dump()
    
    async def healthcheck(self) -> dict:
        """
        Check health of agent manager and agents.
        
        Returns:
            Health status dictionary
        """
        import time
        
        status = {
            "initialized": self._initialized,
            "http_client": self._http_client is not None,
            "agents": {
                "web_crawl_coordinator": "ready",
                "doc_process_coordinator": "ready",
                "query_router": "ready"
            }
        }
        
        # Verify LLM connectivity with caching
        current_time = time.time()
        if self._last_llm_check is None or (current_time - self._last_llm_check) > self._llm_check_ttl:
            try:
                await self._verify_llm_connection()
                self._llm_check_result = "healthy"
            except Exception as e:
                self._llm_check_result = f"error: {str(e)}"
            self._last_llm_check = current_time
        
        status["llm_connection"] = self._llm_check_result
        
        return status


# Global agent manager instance
agent_manager = AgentManager()
