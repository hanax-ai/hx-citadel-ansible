name: AI Fix CodeRabbit Issues
# Phase 2B: Semi-Automated Remediation
# Triggers when Linear issue is labeled with 'coderabbit-critical' or 'coderabbit-quality'

on:
  repository_dispatch:
    types: [linear-issue-created]
  workflow_dispatch:
    inputs:
      issue_id:
        description: 'Linear Issue ID (e.g., DEV-123)'
        required: true
        type: string
      severity:
        description: 'Issue severity'
        required: true
        type: choice
        options:
          - critical
          - high
          - medium
          - low

jobs:
  ai-remediation:
    name: AI Fix for ${{ github.event.inputs.issue_id || github.event.client_payload.issue_id }}
    runs-on: ubuntu-latest
    timeout-minutes: 30

    # Circuit breaker: Skip AI-generated fix branches to prevent infinite loops
    # Only run for critical and high severity
    if: |
      !startsWith(github.ref, 'refs/heads/fix/') &&
      !endsWith(github.ref, '-ai-fix') &&
      (
        (github.event_name == 'workflow_dispatch' && (github.event.inputs.severity == 'critical' || github.event.inputs.severity == 'high')) ||
        (github.event_name == 'repository_dispatch' && (github.event.client_payload.severity == 'critical' || github.event.client_payload.severity == 'high'))
      )

    permissions:
      contents: write
      pull-requests: write
      issues: write

    env:
      LINEAR_API_KEY: ${{ secrets.LINEAR_SECRET }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      ISSUE_ID: ${{ github.event.inputs.issue_id || github.event.client_payload.issue_id }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for branching

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: 'requirements-dev.txt'

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          pip install -r requirements-dev.txt
          # Verify test dependencies are available
          pip show pytest mypy ansible-lint || echo "âš ï¸ Some test tools may not be in requirements-dev.txt"

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Notify Slack - Workflow Started
        if: always()
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -n "$SLACK_WEBHOOK" ] && [ -x "./scripts/slack-notify.sh" ]; then
            ./scripts/slack-notify.sh "$SLACK_WEBHOOK" \
              "ðŸ¤– *AI Remediation Started*" \
              "#36a64f" \
              "Issue" "${{ github.event.inputs.issue_id || github.event.client_payload.issue_id }}" "true" \
              "Severity" "${{ github.event.inputs.severity || github.event.client_payload.severity }}" "true" \
              "Triggered By" "${{ github.actor }}" "true" || echo "Slack notification failed (non-blocking)"
          fi

      - name: Fetch Linear issue details
        id: linear
        run: |
          echo "Fetching Linear issue: $ISSUE_ID"

          # Build GraphQL query using jq for safe JSON construction
          RESPONSE=$(curl -s -X POST https://api.linear.app/graphql \
            -H "Authorization: $LINEAR_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$(jq -n --arg id "$ISSUE_ID" '{
              query: "query($id: String!) { issue(id: $id) { id identifier title description priority branchName state { name } labels { nodes { name } } } }",
              variables: { id: $id }
            }')")

          # Extract fields
          IDENTIFIER=$(echo "$RESPONSE" | jq -r '.data.issue.identifier')
          TITLE=$(echo "$RESPONSE" | jq -r '.data.issue.title')
          DESCRIPTION=$(echo "$RESPONSE" | jq -r '.data.issue.description')
          BRANCH_NAME=$(echo "$RESPONSE" | jq -r '.data.issue.branchName')
          LABELS=$(echo "$RESPONSE" | jq -r '.data.issue.labels.nodes[].name' | tr '\n' ',' | sed 's/,$//')

          # Output to GitHub Actions
          echo "identifier=$IDENTIFIER" >> $GITHUB_OUTPUT
          echo "title=$TITLE" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "labels=$LABELS" >> $GITHUB_OUTPUT

          # Save description to file (may be multi-line)
          echo "$DESCRIPTION" > /tmp/issue_description.txt

      - name: Determine AI tool
        id: ai_tool
        run: |
          LABELS="${{ steps.linear.outputs.labels }}"

          # Routing logic (same as fix-linear-issue.sh)
          if echo "$LABELS" | grep -q "security\|coderabbit-critical"; then
            echo "tool=claude-code" >> $GITHUB_OUTPUT
            echo "reason=Security/Critical issue requires deep reasoning" >> $GITHUB_OUTPUT
          elif echo "$LABELS" | grep -q "coderabbit-quality\|refactor"; then
            echo "tool=cursor" >> $GITHUB_OUTPUT
            echo "reason=Code quality fix - fast iteration" >> $GITHUB_OUTPUT
          elif echo "$LABELS" | grep -q "type-hints\|mypy"; then
            echo "tool=auto-fix" >> $GITHUB_OUTPUT
            echo "reason=Type hints - rules-based fix" >> $GITHUB_OUTPUT
          elif echo "$LABELS" | grep -q "formatting\|linting"; then
            echo "tool=pre-commit" >> $GITHUB_OUTPUT
            echo "reason=Formatting - automated tool" >> $GITHUB_OUTPUT
          else
            echo "tool=claude-code" >> $GITHUB_OUTPUT
            echo "reason=Default to Claude Code for unknown types" >> $GITHUB_OUTPUT
          fi

      - name: Create fix branch
        run: |
          BRANCH_NAME="${{ steps.linear.outputs.branch_name }}"

          # Use Linear's generated branch name if available, otherwise create one
          if [ -z "$BRANCH_NAME" ] || [ "$BRANCH_NAME" = "null" ]; then
            IDENTIFIER="${{ steps.linear.outputs.identifier }}"
            BRANCH_NAME="${IDENTIFIER,,}-ai-fix"
          fi

          echo "Creating branch: $BRANCH_NAME"
          git checkout -b "$BRANCH_NAME"

          echo "branch_name=$BRANCH_NAME" >> $GITHUB_ENV

      - name: Apply AI fix (auto-fix tool)
        if: steps.ai_tool.outputs.tool == 'auto-fix'
        run: |
          echo "Running automated fix..."

          # Type hints auto-fix
          if echo "${{ steps.linear.outputs.labels }}" | grep -q "type-hints"; then
            # Add missing type hints (using mypy suggestions)
            mypy --install-types --non-interactive
            # TODO: Implement auto-fix logic based on mypy output
            echo "Type hints fix applied"
          fi

      - name: Apply AI fix (pre-commit tool)
        if: steps.ai_tool.outputs.tool == 'pre-commit'
        run: |
          echo "Running pre-commit hooks..."
          pre-commit run --all-files || true
          git add -A

      - name: Apply AI fix (Claude Code - MANUAL PLACEHOLDER)
        if: steps.ai_tool.outputs.tool == 'claude-code'
        run: |
          echo "âš ï¸  Claude Code integration requires manual intervention"
          echo "Issue requires complex reasoning - creating PR for human review"
          echo "TODO: Integrate with Claude Code API when available"

          # For now, create PR template for manual fix
          echo "# Manual Fix Required" > /tmp/pr_body.txt
          echo "" >> /tmp/pr_body.txt
          echo "This issue requires Claude Code for complex reasoning." >> /tmp/pr_body.txt
          echo "" >> /tmp/pr_body.txt
          echo "**Linear Issue**: ${{ steps.linear.outputs.identifier }}" >> /tmp/pr_body.txt
          echo "**Title**: ${{ steps.linear.outputs.title }}" >> /tmp/pr_body.txt
          echo "" >> /tmp/pr_body.txt
          cat /tmp/issue_description.txt >> /tmp/pr_body.txt

      - name: Run tests
        id: tests
        continue-on-error: true
        run: |
          echo "Running test suite..."
          pytest tests/ -v --tb=short --maxfail=3 || echo "tests_failed=true" >> $GITHUB_OUTPUT

      - name: Run type checking
        id: mypy
        continue-on-error: true
        run: |
          echo "Running type checking..."
          mypy . || echo "mypy_failed=true" >> $GITHUB_OUTPUT

      - name: Run linting
        id: lint
        continue-on-error: true
        run: |
          echo "Running linting..."
          ansible-lint || echo "lint_failed=true" >> $GITHUB_OUTPUT

      - name: Commit changes
        id: commit
        run: |
          if [[ -n "$(git status --porcelain)" ]]; then
            git add -A
            git commit -m "fix(${{ steps.linear.outputs.identifier }}): ${{ steps.linear.outputs.title }}" \
                       -m "AI-generated fix using ${{ steps.ai_tool.outputs.tool }}" \
                       -m "Reason: ${{ steps.ai_tool.outputs.reason }}" \
                       -m "Resolves ${{ steps.linear.outputs.identifier }}" \
                       -m "ðŸ¤– Generated with AI Issue Remediation (Phase 2B)" \
                       -m "Co-Authored-By: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
            git push -u origin "$branch_name"
            echo "committed=true" >> $GITHUB_OUTPUT
          else
            echo "committed=false" >> $GITHUB_OUTPUT
            echo "âš ï¸  No changes to commit"
          fi

      - name: Notify Slack - No Changes
        if: steps.commit.outputs.committed == 'false'
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -n "$SLACK_WEBHOOK" ]; then
            ./scripts/slack-notify.sh "$SLACK_WEBHOOK" \
              "âš ï¸  *No Changes Generated*" \
              "#ffaa00" \
              "Issue" "${{ steps.linear.outputs.identifier }}" "true" \
              "Reason" "No code changes generated by ${{ steps.ai_tool.outputs.tool }}" "false"
          fi

      - name: Create Pull Request
        if: steps.commit.outputs.committed == 'true'
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          IDENTIFIER: ${{ steps.linear.outputs.identifier }}
          TITLE: ${{ steps.linear.outputs.title }}
          AI_TOOL: ${{ steps.ai_tool.outputs.tool }}
          AI_REASON: ${{ steps.ai_tool.outputs.reason }}
          TEST_STATUS: ${{ steps.tests.outputs.tests_failed == 'true' && 'âŒ Failed' || 'âœ… Passed' }}
          MYPY_STATUS: ${{ steps.mypy.outputs.mypy_failed == 'true' && 'âŒ Failed' || 'âœ… Passed' }}
          LINT_STATUS: ${{ steps.lint.outputs.lint_failed == 'true' && 'âŒ Failed' || 'âœ… Passed' }}
        run: |
          # Read issue description
          DESCRIPTION=$(cat /tmp/issue_description.txt)

          # Build PR body using printf (avoid heredoc YAML issues)
          {
            printf "Resolves %s\n\n" "${IDENTIFIER}"
            printf "## CodeRabbit Finding\n%s\n\n" "${TITLE}"
            printf "## AI Tool Used\n**Tool**: %s\n**Reason**: %s\n\n" "${AI_TOOL}" "${AI_REASON}"
            printf "## Changes Applied\n%s\n\n" "${DESCRIPTION}"
            printf "## Test Results\n"
            printf -- "- **Unit Tests**: %s\n" "${TEST_STATUS}"
            printf -- "- **Type Checking**: %s\n" "${MYPY_STATUS}"
            printf -- "- **Linting**: %s\n\n" "${LINT_STATUS}"
            printf "## Review Checklist\n"
            printf -- "- [ ] Code changes are correct\n"
            printf -- "- [ ] Tests are passing\n"
            printf -- "- [ ] No security issues introduced\n"
            printf -- "- [ ] Documentation updated (if needed)\n\n"
            printf "## Next Steps\n"
            printf "1. Review the AI-generated fix\n"
            printf "2. Run additional manual tests if needed\n"
            printf "3. Approve and merge if satisfied\n\n"
            printf -- "---\n\n"
            printf "ðŸ¤– Generated with AI Issue Remediation Script (Phase 2B)\n"
            printf "Resolves %s\n" "${IDENTIFIER}"
          } > /tmp/pr_body.txt

          # Create PR
          gh pr create \
            --title "Fix ${IDENTIFIER}: ${TITLE}" \
            --body-file /tmp/pr_body.txt \
            --label "coderabbit-fix,ai-generated,${AI_TOOL}" \
            --reviewer "" \
            --assignee "${{ github.actor }}"

          PR_URL=$(gh pr view --json url -q .url)
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT

      - name: Notify Slack - PR Created
        if: steps.create_pr.outputs.pr_url
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -n "$SLACK_WEBHOOK" ] && [ -x "./scripts/slack-notify.sh" ]; then
            ./scripts/slack-notify.sh "$SLACK_WEBHOOK" \
              "âœ… AI Fix PR Created" \
              "#36a64f" \
              "Issue" "${{ steps.linear.outputs.identifier }}" "true" \
              "PR" "${{ steps.create_pr.outputs.pr_url }}" "false" \
              "Tool" "${{ steps.ai_tool.outputs.tool }}" "true" \
              "Tests" "${{ steps.tests.outputs.tests_failed == 'true' && 'âŒ Failed' || 'âœ… Passed' }}" "true"
          fi

      - name: Update Linear issue with PR link
        if: steps.create_pr.outputs.pr_url
        run: |
          # Update Linear issue with comment using jq for safe JSON
          PR_URL="${{ steps.create_pr.outputs.pr_url }}"
          AI_TOOL="${{ steps.ai_tool.outputs.tool }}"
          TEST_RESULT="${{ steps.tests.outputs.tests_failed == 'true' && 'âŒ Tests failed' || 'âœ… Tests passed' }}"
          
          # Build comment with printf
          COMMENT=$(printf "âœ… AI fix generated!\n\nPull Request: %s\nAI Tool: %s\nTest Results: %s\n\nPlease review the PR and merge if satisfied." "${PR_URL}" "${AI_TOOL}" "${TEST_RESULT}")

          curl -s -X POST https://api.linear.app/graphql \
            -H "Authorization: $LINEAR_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$(jq -n --arg issueId "$ISSUE_ID" --arg body "$COMMENT" '{
              query: "mutation($issueId: String!, $body: String!) { commentCreate(input: { issueId: $issueId, body: $body }) { success } }",
              variables: { issueId: $issueId, body: $body }
            }')"

      - name: Notify Slack - Workflow Failed
        if: failure()
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -n "$SLACK_WEBHOOK" ]; then
            ISSUE_ID="${{ github.event.inputs.issue_id || github.event.client_payload.issue_id }}"
            RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

            ./scripts/slack-notify.sh "$SLACK_WEBHOOK" \
              "âŒ *AI Remediation Failed*" \
              "#ff0000" \
              "Issue" "$ISSUE_ID" "true" \
              "Error" "Check workflow logs for details" "false" \
              "Logs" "$RUN_URL" "false"
          else
            echo "::error::AI remediation failed for $ISSUE_ID"
          fi

      - name: Summary
        run: |
          echo "## ðŸ¤– AI Remediation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Issue**: ${{ steps.linear.outputs.identifier }} - ${{ steps.linear.outputs.title }}" >> $GITHUB_STEP_SUMMARY
          echo "**AI Tool**: ${{ steps.ai_tool.outputs.tool }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch**: $branch_name" >> $GITHUB_STEP_SUMMARY
          echo "**PR**: ${{ steps.create_pr.outputs.pr_url || 'Not created' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Test Results" >> $GITHUB_STEP_SUMMARY
          echo "- Unit Tests: ${{ steps.tests.outputs.tests_failed == 'true' && 'âŒ Failed' || 'âœ… Passed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- Type Checking: ${{ steps.mypy.outputs.mypy_failed == 'true' && 'âŒ Failed' || 'âœ… Passed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- Linting: ${{ steps.lint.outputs.lint_failed == 'true' && 'âŒ Failed' || 'âœ… Passed' }}" >> $GITHUB_STEP_SUMMARY
# Refresh workflow registry
