#!/usr/bin/env python3
"""
Enhanced Health Check Implementation for Shield MCP Server
Generated by Ansible for {{ ansible_hostname }}

Features:
- Async timeouts for all dependency checks
- Comprehensive dependency status
- Structured response format
- Response time tracking
"""

import asyncio
from datetime import datetime, timezone
from typing import Dict, Any
import httpx
from qdrant_client import AsyncQdrantClient
import os

# Configuration from environment
QDRANT_URL = os.getenv("QDRANT_URL")
QDRANT_API_KEY = os.getenv("QDRANT_API_KEY")
ORCHESTRATOR_URL = os.getenv("ORCHESTRATOR_URL")
OLLAMA_URL = os.getenv("OLLAMA_URL")
TIMEOUT_SECONDS = 5.0


async def check_qdrant_health() -> Dict[str, Any]:
    """Check Qdrant vector database health with timeout"""
    try:
        start_time = asyncio.get_event_loop().time()
        qdrant = AsyncQdrantClient(url=QDRANT_URL, api_key=QDRANT_API_KEY)
        
        # Get collections with timeout
        collections = await asyncio.wait_for(
            qdrant.get_collections(),
            timeout=TIMEOUT_SECONDS
        )
        
        elapsed_ms = (asyncio.get_event_loop().time() - start_time) * 1000
        
        return {
            "status": "operational",
            "collections_count": len(collections.collections),
            "collections": [c.name for c in collections.collections],
            "response_time_ms": round(elapsed_ms, 2),
            "url": QDRANT_URL
        }
    
    except asyncio.TimeoutError:
        return {
            "status": "timeout",
            "error": f"Connection timeout after {TIMEOUT_SECONDS}s",
            "url": QDRANT_URL
        }
    except Exception as e:
        return {
            "status": "error",
            "error": str(e),
            "error_type": type(e).__name__,
            "url": QDRANT_URL
        }


async def check_orchestrator_health() -> Dict[str, Any]:
    """Check Orchestrator API health with timeout"""
    try:
        start_time = asyncio.get_event_loop().time()
        
        async with httpx.AsyncClient(timeout=TIMEOUT_SECONDS) as client:
            response = await client.get(f"{ORCHESTRATOR_URL}/health")
            
        elapsed_ms = (asyncio.get_event_loop().time() - start_time) * 1000
        
        return {
            "status": "operational" if response.status_code == 200 else "degraded",
            "status_code": response.status_code,
            "response_time_ms": round(elapsed_ms, 2),
            "url": ORCHESTRATOR_URL
        }
    
    except asyncio.TimeoutError:
        return {
            "status": "timeout",
            "error": f"Connection timeout after {TIMEOUT_SECONDS}s",
            "url": ORCHESTRATOR_URL
        }
    except httpx.ConnectError:
        return {
            "status": "unreachable",
            "error": "Connection refused (service not running or not yet deployed)",
            "url": ORCHESTRATOR_URL
        }
    except Exception as e:
        return {
            "status": "error",
            "error": str(e),
            "error_type": type(e).__name__,
            "url": ORCHESTRATOR_URL
        }


async def check_ollama_health() -> Dict[str, Any]:
    """Check Ollama LLM service health with timeout"""
    try:
        start_time = asyncio.get_event_loop().time()
        
        async with httpx.AsyncClient(timeout=TIMEOUT_SECONDS) as client:
            # Check /api/tags endpoint for available models
            response = await client.get(f"{OLLAMA_URL}/api/tags")
            
        elapsed_ms = (asyncio.get_event_loop().time() - start_time) * 1000
        
        if response.status_code == 200:
            models_data = response.json()
            models = models_data.get("models", [])
            
            return {
                "status": "operational",
                "models_available": len(models),
                "models": [m.get("name") for m in models],
                "response_time_ms": round(elapsed_ms, 2),
                "url": OLLAMA_URL
            }
        else:
            return {
                "status": "degraded",
                "status_code": response.status_code,
                "response_time_ms": round(elapsed_ms, 2),
                "url": OLLAMA_URL
            }
    
    except asyncio.TimeoutError:
        return {
            "status": "timeout",
            "error": f"Connection timeout after {TIMEOUT_SECONDS}s",
            "url": OLLAMA_URL
        }
    except httpx.ConnectError:
        return {
            "status": "unreachable",
            "error": "Connection refused",
            "url": OLLAMA_URL
        }
    except Exception as e:
        return {
            "status": "error",
            "error": str(e),
            "error_type": type(e).__name__,
            "url": OLLAMA_URL
        }


async def comprehensive_health_check() -> Dict[str, Any]:
    """
    Comprehensive health check for all Shield MCP dependencies
    
    Returns:
        dict: Complete health status with dependency checks
    """
    health = {
        "server": {
            "status": "operational",
            "name": os.getenv("FASTMCP_SERVER_NAME", "Shield MCP Server"),
            "version": os.getenv("SERVER_VERSION", "1.0.0"),
            "transport": os.getenv("FASTMCP_TRANSPORT", "sse"),
            "port": int(os.getenv("FASTMCP_PORT", 8081))
        },
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "hostname": os.getenv("HOSTNAME", "unknown"),
        "dependencies": {}
    }
    
    # Check all dependencies concurrently
    qdrant_task = check_qdrant_health()
    orchestrator_task = check_orchestrator_health()
    ollama_task = check_ollama_health()
    
    qdrant_health, orchestrator_health, ollama_health = await asyncio.gather(
        qdrant_task,
        orchestrator_task,
        ollama_task,
        return_exceptions=True
    )
    
    # Handle any exceptions from gather
    if isinstance(qdrant_health, Exception):
        health["dependencies"]["qdrant"] = {"status": "error", "error": str(qdrant_health)}
    else:
        health["dependencies"]["qdrant"] = qdrant_health
    
    if isinstance(orchestrator_health, Exception):
        health["dependencies"]["orchestrator"] = {"status": "error", "error": str(orchestrator_health)}
    else:
        health["dependencies"]["orchestrator"] = orchestrator_health
    
    if isinstance(ollama_health, Exception):
        health["dependencies"]["ollama"] = {"status": "error", "error": str(ollama_health)}
    else:
        health["dependencies"]["ollama"] = ollama_health
    
    # Calculate overall status
    dep_statuses = [
        health["dependencies"]["qdrant"].get("status"),
        health["dependencies"]["orchestrator"].get("status"),
        health["dependencies"]["ollama"].get("status")
    ]
    
    if all(s == "operational" for s in dep_statuses):
        health["overall_status"] = "healthy"
    elif any(s in ["error", "unreachable"] for s in dep_statuses):
        # Orchestrator being unreachable is expected during initial deployment
        if orchestrator_health.get("status") == "unreachable":
            critical_deps = [
                health["dependencies"]["qdrant"].get("status"),
                health["dependencies"]["ollama"].get("status")
            ]
            if all(s == "operational" for s in critical_deps):
                health["overall_status"] = "healthy_partial"
                health["note"] = "Orchestrator not yet deployed (expected during initial setup)"
            else:
                health["overall_status"] = "unhealthy"
        else:
            health["overall_status"] = "unhealthy"
    elif any(s in ["timeout", "degraded"] for s in dep_statuses):
        health["overall_status"] = "degraded"
    else:
        health["overall_status"] = "unknown"
    
    return health


# Example usage (for testing)
if __name__ == "__main__":
    import json
    result = asyncio.run(comprehensive_health_check())
    print(json.dumps(result, indent=2))
